
AEVILIA GB MAP ENGINE
As modular as I could manage to make it be.


I- CONCEPTS

There are several abstractions the engine uses. They are intended to make programming and debugging easier.


1. Overworld frame

The overworld loop is independent from the rest of the game. Most prominent example : the button registers.
Basically, the main button registers - hHeldButtons and hPressedButtons - are updated by the VBlank handler. An attentive reader will wonder what happens when an overworld frame spans more than one GB frame (ie. the game lags).
The answer is, input may be inconsistent across a function (this used to cause softlocks when moving at speeds too high, for technical reasons. 'Twas fun patching, though).
To fix this, the overworld loop has its own set of :
 - Frame counter (hOverworldFrameCounter)
 - Held buttons (hOverworldHeldButtons)
 - Pressed buttons (hOverworldPressedButtons)
The functioning of the frame counter and held buttons are pretty much what you'd expect. The pressed buttons, however, follow a slightly more complicated logic.
The game applies the same logic as it does with hPressedButtons (but uses hOverworldHeldButtons instead), but before writing back, it also applies the mask hOverworldButtonFilter.
This allows to ignore certain actions (this is notable in the tutorial).
There also are two other options to ignore the player's actions.
wUnlinkJoypad, when non-zero, does NOT process MovePlayer nor the frame "actions" (pressed A, B, etc.). It should not be interfaced with directly, but rather through PreventJoypadMovement and AllowJoypadMovement.
hIgnorePlayerActions does exactly the same, but is reset at the beginning of every frame. A few exceptions exist, done by skipping the resetting instruction (for example, the battle trigger does this to force the next frame to not take input on the following frame). It's basically a one-frame `wUnlinkJoypad`, and can be interfaced with directly. Notable uses include walking interactions lasting for more than a single frame, to avoid parasitic actions (since overworld joypad inputs will not be updated, pressing A on the same frame would also process interactions after the walking interaction returns).


2. Camera

Everything in the game is rendered relatively to the camera. Also, the camera is a fully independent entity (from the player), which makes stuff such as cutscenes easier to make without any stupid hacks.
On every overworld frame, the camera's position is transferred to the GB's scrolling registers, and all graphics-related operations are done relatively to the camera.
Most importantly, redrawing the terrain. Because, obviously, the maps in this game are way bigger than the GBC's 20x18 tile memory. Thus, tile data is updated as the camera (and thus the scrolling registers) moves around.
The was the camera is designed, it can only move by 16 pixels in a frame. But for cosmetic reasons, the max speed was decreased to 15 pixels/frame.
Next is camera locking. Based on the current map's width and height, the camera will lock at the edges of the map. Note that this is done by fully "snapping" the camera to the "edge" position, thus overriding max cam speed. If the camera is "OoB" on one frame, the next frame will have the camera snap and redraw only one row, potentially leading to glitchiness.


3. NPCs

An NPC is an entity that exists within the overworld. An NPC has a visual existence, a physical existence, and interaction properties.
In contrast, the player entity only has a physical existence (though it's only affected by NPCs, and not the opposite).
An NPC has :
 - A position
 - A hitbox (both for physical and interactions purposes)
 - An interaction script (short for "what happens when you interact with it")
 - An appearance (short for "what you see on-screen"), which is a set of "singleton" appearances
 - A movement length (which serves both for its obvious purpose and to give the NPC a walking animation)
 - Movement permissions (which are sliiightly complicated)
 - A movement speed
 - Displacements (which track how much the NPC has moved, to restrict the movement)
 - An unused byte
The position is pmuch standard. Two 16-bit ints, same as the camera and the player and everything else : first one for the Y axis (vertical), second one for the X axis.
The hitbox is also standard : two 8-bit ints, one for the Y axis, then one for the X axis. Note that this only affects the interaction hitbox, not the graphical hitbox - it stays a 16x16 sprite.
The interaction script is actually just a byte, which is the index to use in the map's NPC interaction table. An entry is a 2-byte pointer to a text stream that is processed when the NPC is interacted with.
The appearance is an index using which using which the NPC's tile IDs will be computed. There's no table here, since all tiles are loaded into VRAM at tileset-loading time. Note that the byte actually contains two bits of data : IIIIIIDD ; "I" is the appearance that was just described, "D" is the direction - following the standard Up-Down-Left-Right scheme.
The movement length is, most of the time, just that. How many pixels the NPC will travel before entering a waiting state. But if the NPC is in a waiting state, this instead is the number of frames to wait until the NPC exits the waiting state. See below. The movement length also controls the walking animation, even if the NPC's locking bit is reset.
The movement permissions are a bitfield, indicating both what state the NPC is in at a given moment, and what actions it is allowed to take. Bitfield : TTMMRLDD. TT = turning permissions (first, permission for vertical axis, then permission for horizontal axis), MM = moving permissions (same), R = "resting" bit (differentiates a moving NPC from a resting NPC), L = "locking" bit (if reset, the function completely skips the NPC), and DD = movement direction (meaningless in waiting and resting states). See below.

3.i  NPC movement

An NPC is an entity that can move on its own. There's one function processing alll of the NPC movement, so here it is, summed up.

MoveNPCs:
  - For each NPC
    - Check bit 2 of the movement flags
	- If reset :
	  - Completely ignore NPC
	- Otherwise :
	  - If the NPC's step counter is zero :
	    ° NPC is in "wait" state
		- Check if NPC has any "turning" permissions
		- If no :
		  - Do nothing (note that this doesn't overwrite the "resting" bit)
		- If yes :
		  - Pull random int
		  - If all bits 0-5 (mask $3F) of the rand int's high byte are reset :
			- If the NPC can turn on only one axis :
			  - Pick that axis
			- Otherwise :
			  - If bit 1 of the rand int's low byte is reset :
				- Pick the vertical axis
			  - Otherwise :
			  - Pick the horizontal axis
			- If bit 2 of the rand int's low byte is reset :
			  - Turn in the "negative" direction (U/L)
			- Otherwise :
			  - Turn in the "positive" direction (D/R)
			- Write back flags (including forcing the NPC in a "moving" state, even if the "resting" bit was set)
			- Turn NPC to face the "movement"'s direction
			- If bit 0 of the rand int's low byte is reset :
			  - Do nothing else
			- Otherwise :
			  - If the NPC isn't allowed to move on the picked axis :
				° NPC only turns, so it stalls for a moment before picking an action
				- AND low byte of rand int with $F8
				- Roll right once
				- Write as movement length
				- Set resting bit
			  - Otherwise :
				° NPC starts moving
				- Pull another random int
				- Write the high byte as the movement length
				° Will process one frame of movement immediately after (to apply collision, mostly.), thus directly jumps into the "Otherwise" code labelled with a `*`
		  - Otherwise :
			- Do nothing else (the NPC did nothing, but RNG has been advanced)
	  - Otherwise : *
		- If the NPC's "resting" bit is set :
		  ° NPC is in "rest" state
		  - Decrement movement counter (which is a waiting counter, in this state)
		  - If the movement counter reached zero :
		    ° NPC steps into "wait" mode
		    - Reset resting bit
		  - Otherwise :
		    - Do nothing else
		- Otherwise :
		  ° NPC is in "moving" mode
		  - Remember speed for later
		  - Subtract speed from remaining pixels
		  - If it caused an overflow :
		    - Replace remembered speed with remaining pixels (ie. cap speed on last step)
			- Consider there are 0 pixels remaining
		  - Write number of pixels back
		  - If it's zero :
		    ° NPC finished walking
			- Pull random int
			- Write it to step counter
			- Set resting bit
		  - Copy NPC's coords to wTempBuf
		  - Apply movement vector to these coords
		  - Perform collision check
		  - If collision occurs :
		    - Go to `**` code (stopNPC)
		  - Otherwise :
		    - Update the axis's displacement
			- If it generated an overflow : (**)
			  - Pull random int
			  - Write it to step counter
			  - Set resting bit
			- Otherwise :
			  - Copy wTempBuf to NPC's coords (ie. move NPC)
	- Move to next NPC struct

A couple of notes :
 - A resting NPC doesn't touch RNG.
 - A waiting NPC will poke RNG at least once, and if it starts moving, it will poke RNG a second time (note : this restricts the possible range of steps, but how exactly ?)
 - A moving NPC will only poke RNG if it stops. Note : if an NPC bonks on its last step, it will poke RNG twice instead (since the "last step" code still runs the following code.
 - A locked NPC draws its name from that it's "locked" in time ; as soon as it's "unlocked", it resumes all operations. It's more like a "pause" button, in a way.
 - A "waiting" NPC with its "resting" bit set is technically invalid, but actually corrected as soon as the function parses the NPC. Though, any "scripted" movement, ie. done by simply setting the step counter, will not correct the invalid state unless the NPC is processed at least once in its waiting state.
 - Collision is done at run-time and only using the target position, which means an NPC may not "bonk" into a wall if its speed is >1.
 - For the same reason, if the NPC is moving too fast, it may just zoom through solid things (even more since I optimized collision detection to only use the two "front" points)
 - Also, the collision detection only checks the two "edges" of the hitbox, meaning too large a hitbox will cause oddities.
 - NPCs assume a 16x16 collision box for the player, to sweep an issue under the carpet (if the NPC's hitbox "encompassed" the player's, NPCs could go straight through the player... which was much more prominent with horizontal movement)
